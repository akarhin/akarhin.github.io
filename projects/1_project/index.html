<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> ML-based gearbox fault diagnosis | Aku T. Karhinen </title> <meta name="author" content="Aku T. Karhinen"> <meta name="description" content="An entry-level intelligent fault diagnosis project"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://akarhin.github.io/projects/1_project/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://akarhin.github.io/"> <span class="font-weight-bold">Aku</span> T. Karhinen </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">ML-based gearbox fault diagnosis</h1> <p class="post-description">An entry-level intelligent fault diagnosis project</p> </header> <article> <h2 id="introduction">Introduction</h2> <p>While traditional condition monitoring (CM) done by vibration analysis is effective, it is not very scalable, requiring more well educated data analysts for accurate diagnosis. While the calulated features such as the RMS do alleviate this problem, reducing the vibration signature into specific features does not necessarily capture the entire distribution of faulty vibration behaviour. Therefore, the field of intelligent fault diagnosis (IFD) aims to automate CM with machine learning (ML) solutions. The aim is to produce intelligent models that take the vibration signature or a multitude of calculated features as their input and produce a health class as the output. The field has gained a lot of traction and many articles are published aiming to improve their use.</p> <p>This project explores the application of Machine Learning (ML) for gearbox fault diagnosis. The goal was to develop intelligent models that can accurately determine whether a gearbox is healthy or faulty based on processed vibration data from accelerometers. The comparison focuses on two traditional ML models: the Support Vector Machine (SVM) and the Multilayer Perceptron (MLP). First, traditional CM methods are introduced for comparison. Second, the beforementioned ML models are introduced. Third, the results are shown and a superior ML model is chosen based on perceived performance. Finally, the project concludes by discussing further improvements applicable.</p> <div class="row justify-content-sm-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/gearbox-480.webp 480w,/assets/img/gearbox-800.webp 800w,/assets/img/gearbox-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/gearbox.jpg" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h2 id="traditional-cm-of-gears">Traditional CM of gears</h2> <p>The monitoring of rotating machines is often conducted with vibration analysis due to its non-invasive nature compared to other monitoring methods such as lubricant analysis. Additionally, vibration analysis shows instant changes in the vibration signature when faults do occurs, facilitating fast reaction times and proper maintenacne actions. Traditional vibration analysis is conducted with techniques such as time-domain analysis, frequency analysis and envelope analysis.</p> <p>Time-domain analysis can be conducted by directly comparing exctracted vibration signatures from a healthy and a faulty machine. Other forms of time-domain analysis include calculating features, such as the Root-mean square (RMS) value from the vibration signature and doing a similar comparison. By comparing their RMS values, one can determine which signal has greater overall energy or intensity, higher energy in similar operating conditions often signaling faulty behaviour. Features like this can be useful for the automation of CM systems, since raw time-domain analysis requires more finesse compared to the comparison of singular numerical features.</p> <p>Frequency-domain analysis transforms the vibration signature into frequency domain with a transformation operation such as the Fourier transform. One of the main reasons for using a frequency-domain representations is to simplify the processed signal into its frequency components, reducing the noise present in the signature. For rotating machinery, specific faults present themself in specific fault frequencies further elaborated below. Frequency representation makes finding these specific frequencies easier compared to time-domain analysis.</p> <p>Some faults are strongly present in the harmonic frequencies, or integer multiples of specific fault frequencies. Envelope analysis aims to examine the high frequency components present in the vibration signature. One form of envelope analysis involves taking a Hilbert transformation of the raw measurement, extracting the envelope by taking the absolute value from the analytical signal, transforming the resulting signal into the order domain (1 order = 1 x Rpm in Hz) and then calculating the power spectral density (PSD) in the order domain. From the PSD, known fault frequencies related to the rotating speed of the system can be examined to determine if a fault mode corresponding to specific fault frequencies is present.</p> <p>The main characteristic fault frequencies in gears include the Gear mesh frequency (GMF), sidebands, and harmonics. <strong>GMF</strong> is the frequency at which gear teeth mesh together. It is a fundamental frequency in the vibration signal of a gearbox and is used to detect gear faults. It is calculated with the following equation:</p> \[\text{GMF} = N \times f_s\] <p>where:</p> <ul> <li>( N ) is the number of teeth on the gear</li> <li>( f_s ) is the shaft rotational frequency (in Hz)</li> </ul> <p><strong>Sidebands</strong> are frequencies that appear around the gear mesh frequency and its harmonics. They are indicative of modulation effects due to gear faults such as wear, misalignment, or eccentricity. Sidebands are calculated with:</p> \[\text{Sidebands} = \text{GMF} \pm k \times f_s\] <p>where:</p> <ul> <li>( k ) is an integer (1, 2, 3, …)</li> <li>( f_s ) is the shaft rotational frequency (in Hz)</li> </ul> <p><strong>Harmonics</strong> of the GMF are integer multiples of the GMF. The presence of harmonics and their relative amplitudes can provide information about the severity and type of gear faults present. Harmonics of the GMF are calculated with:</p> \[\text{Harmonics} = m \times \text{GMF}\] <p>where:</p> <ul> <li>( m ) is an integer (1, 2, 3, …)</li> </ul> <p><strong>The hunting thooth frequency</strong> (HTF) is the rate at which a tooth in one gear engages with a specific tooth in another gear. HTF can be used to determine faults occuring at a specific thooth. It is calculated with:</p> \[HTF = \frac{\text{GMF} \times N_a}{T_{out} \times T_{in}}\] <p>where:</p> <ul> <li>GMF is the gear meshing frequency</li> <li>N_a is the common frequency</li> <li>T_in = pinion teeth</li> <li>T_out = gear teeth</li> </ul> <p>The common frequency is determined by dividing the amount of theeth from both gears in the gearpair into integer multiples. For example, 24 can be divided into 1<em>24, 2</em>12, 3<em>8 and 4</em>6. The highest number present in both of the gears integer multiples is the common frequency. For example, 12 theeth gear and the previous gear have a common frequency of 12, since it is the highest common integer present in the integer multiples of both gears. This is a bad design choice since we have an even gear ratio. This can lead to faults developing in specific theeth in the pinion affecting specific theeth on the corresponding gear, accelerating the wear induced in these specific gear theeth locations.</p> <p>The following section explains some common fault modes and their effect on the specific fault frequencies and the vibration signature in the frequency domain.</p> <h3 id="misalignment">Misalignment</h3> <ul> <li> <strong>Symptoms:</strong> Amplitude increase in the axial direction of the axes. Appearance of 2X, 3X RPM, and 2X, 3X GMF.</li> <li> <strong>Causes:</strong> Wrong alignment procedures, loss of tolerances, thermal expansion.</li> </ul> <h3 id="excessive-wear">Excessive Wear</h3> <ul> <li> <strong>Symptoms:</strong> Increased amplitude of the 1XGMF and 1X sidebands. Appearance of gear’s natural frequency.</li> <li> <strong>Causes:</strong> Improper lubrication, contaminated or degraded lubricant. Change of wear pattern. Assembly and adjustment failures.</li> </ul> <h3 id="excessive-backlash">Excessive Backlash</h3> <ul> <li> <strong>Symptoms:</strong> Increased amplitude of the 1XGMF and 1X sidebands. Appearance of gear’s natural frequency.</li> <li> <strong>Causes:</strong> Bad assembly, design or manufacturing flaws, wear.</li> </ul> <h3 id="overload">Overload</h3> <ul> <li> <strong>Symptoms:</strong> Increased amplitude of 1XGMF, multiple 1X RPM sidebands.</li> <li> <strong>Causes:</strong> Operation outside of design conditions.</li> </ul> <h3 id="high-friction">High Friction</h3> <ul> <li> <strong>Symptoms:</strong> Increase of the 1XGMF component, rise of the global amplitude in acceleration, and shock pulse.</li> <li> <strong>Causes:</strong> Lubrication failures and/or lubricant quality. Component assembly and tolerances.</li> </ul> <h3 id="broken-teeth">Broken Teeth</h3> <ul> <li> <strong>Symptoms:</strong> Synchronous impact pattern in the time waveform with 1X of damaged gear.</li> <li> <strong>Causes:</strong> Overload, fatigue, adjustments and tolerances.</li> </ul> <h3 id="assembly-or-manufacturing-failures">Assembly or Manufacturing Failures</h3> <ul> <li> <strong>Symptoms:</strong> Increased amplitude of the 1XGMF and 1X sidebands. Appearance of Hunting Tooth Frequency (HFT) or the Gear Assembly Phase Frequency (GAPF).</li> <li> <strong>Causes:</strong> Manufacturing defects in geometry and/or materials. Irregular teeth surface. Changes from the original wear pattern.</li> </ul> <h2 id="the-nyquist-frequency">The Nyquist frequency</h2> <p>During the data gathering process, something called the Nyquist frequency is often discussed. The Nyquist frequency corresponds to the frequency thats cycle length is half of the samplers frequency. Therefore, for example, a sampling rate of 3 kHz has a Nyquist frequency of 1.5 kHz. Conversely, a frequency of 1.5 kHz has a Nyquist rate of 3 kHz. The Nyquist rate is used to mimimize the effect of aliasing during data acquisition. It is stated that to avoid aliasing, the Nyquist rate of the phenomena monitored has to be smaller or at least equal to the sampling rate. That is, if we want to monitor high frequency phenomena, the sampling frequency has to be at least double the monitored phenomenas frequency, in order to avoid aliasing in the signal.</p> <h2 id="dataset-description">Dataset Description:</h2> <p>Sourced from Kaggle, the dataset includes vibration data from four accelerometers placed on a gearbox under different loads. It contains 20 files: 10 for healthy gearboxes and 10 for gearboxes with a broken tooth, each under different load conditions (0% - 90%). The four vibration sensors placed in four different direction, and under variation of load from ‘0’ to ‘90’ percent. Data points were created by segmenting each file into 3000 measurement point sized windows and labeled. Measurement point corresponds to a singluar measurement taken with each 4 accelerometers at the same point in time. Each file had an unique amount of measurement points. Therefore, the first 80 000 sample points were used from each file to balance the dataset. This leads 400 datapoints overall, 200 from a healthy gearbox and 200 from a faulty machine.</p> <p>Fast Fourier Transform (FFT) was applied to reduce noise and enhance signal features. From the FFT results, the absolute values were taken due to the limitations of the ML model structures not being able to process imaginary parts of the FFT output. Data was randomly split into training (70%) and test (30%) sets, while making sure each set had the same amount of healthy and faulty data points. Scikit-learns cross_val_score was utilized, therefore requiring no seperate validation set.</p> <p>The dataset is publicly available (you need a Kaggle account) <a href="https://www.kaggle.com/datasets/brjapon/gearbox-fault-diagnosis" rel="external nofollow noopener" target="_blank">here</a>. The SpectraQuest Gearbox Prognostic Simulator test setup has been introduced <a href="https://spectraquest.com/gearbox-prognostics-simulator/" rel="external nofollow noopener" target="_blank">here</a>.</p> <div class="row justify-content-sm-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/spectraquest_2-480.webp 480w,/assets/img/spectraquest_2-800.webp 800w,/assets/img/spectraquest_2-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/spectraquest_2.jpg" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figcaption style="text-align: center; margin-top: 10px;">SpectraQuest Gearbox Prognostic Simulator setup.</figcaption> </div> </div> <h2 id="the-mlp">The MLP:</h2> <p>A Multilayer Perceptron (MLP) is a type of artificial neural network used primarily for supervised learning tasks like classification and regression. The structure of an MLP consists of an input layer, one or more hidden layers, and an output layer. Each layer is composed of neurons, where each neuron in one layer is connected to every neuron in the next layer, forming a fully connected feedforward network. The MLP structure was chosen, since it is considered to be the default, most simple neural network structure.</p> <div class="row justify-content-sm-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/mlp-480.webp 480w,/assets/img/mlp-800.webp 800w,/assets/img/mlp-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/mlp.jpg" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figcaption style="text-align: center; margin-top: 10px;">A simple MLP structure.</figcaption> </div> </div> <p>In a MLP, the input layer (Some think that the input layer does not exist due to it not having any calculations. However, the term “input layer” is still widely used, therefore its use also in this project.) receives the raw data, which is then processed through the hidden layers. These hidden layers are responsible for learning and extracting features from the data through weighted connections and activation functions, which introduce non-linearity into the model, enabling it to learn complex patterns.</p> <div class="row justify-content-sm-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/Neuron-480.webp 480w,/assets/img/Neuron-800.webp 800w,/assets/img/Neuron-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/Neuron.jpg" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figcaption style="text-align: center; margin-top: 10px;">Visualized neuron calculation in a MLP.</figcaption> </div> </div> <p>The output layer produces the final prediction, which can be a single value in the case of regression tasks or a probability distribution over different classes for classification tasks. The learning process involves adjusting the weights of the connections through a method called backpropagation, which uses the gradient of a loss function to minimize the error between the predicted and actual outputs.</p> <p>This project utilized scikit-learn’s MLPClassifier with logistic loss and hyperbolic tan activation functions. MLP was chosen for its capability to handle nonlinear relationships in time-series data. The utilized activation function was the Tanh:</p> \[\text{Tanh}(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}\] <p>Naturally, the hypothesis space for an MLP is:</p> <p>\(h : \mathbb{R} \rightarrow \mathbb{R}\).</p> <p>The chosen loss function was the logistic loss:</p> \[\text{Logistic Loss}(y, \hat{y}) = - \left[ y \log(\hat{y}) + (1 - y) \log(1 - \hat{y}) \right]\] <h2 id="the-svm">The SVM:</h2> <p>A Support Vector Machine (SVM) is a supervised learning algorithm used primarily for classification and regression tasks. The main goal of an SVM is to find the optimal hyperplane that best separates the data points of different classes in a high-dimensional space.</p> <div class="row justify-content-sm-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/linear_svm-480.webp 480w,/assets/img/linear_svm-800.webp 800w,/assets/img/linear_svm-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/linear_svm.jpg" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figcaption style="text-align: center; margin-top: 10px;">An visualization of a linear SVM.</figcaption> </div> </div> <p>In the case of classification, an SVM constructs a hyperplane or set of hyperplanes in a high-dimensional space. These hyperplanes are chosen to maximize the margin between different classes, which is the distance between the hyperplane and the nearest data points from any class, known as support vectors. By maximizing this margin, the SVM aims to improve the model’s ability to generalize to unseen data.</p> <p>For linearly separable data, a linear hyperplane is sufficient. However, for non-linearly separable data, SVMs use a technique called the kernel trick. The kernel trick involves transforming the original data into a higher-dimensional space where a linear separator can be found. Common kernels include the polynomial kernel, radial basis function (RBF) kernel, and sigmoid kernel.</p> <div class="row justify-content-sm-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nonlinear_svm-480.webp 480w,/assets/img/nonlinear_svm-800.webp 800w,/assets/img/nonlinear_svm-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/nonlinear_svm.jpg" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figcaption style="text-align: center; margin-top: 10px;">An visualization of an non-linear SVM.</figcaption> </div> </div> <p>This project implemented the SVM using scikit-learn’s SVC with a sigmoid kernel function. Kernel SVM was selected for its ability to construct high-dimensional features and separate data points non-linearly. Sigmoid can be represented as:</p> \[S(x) = \frac{e^x}{e^x + 1}\] <p>The used loss function for the SVM was the Hinge loss:</p> \[\text{Loss}((x, y), h) := \max\left(0, 1 - y \cdot h(x)\right) + \lambda \|w\|\] <h2 id="results">Results</h2> <p>Both models performed perfectly on preprocessed data, achieving a test accuracy of 1.00 and perfect cross-validation scores. However, when evaluated on raw data, SVM outperformed MLP with a test accuracy of 0.4417 and validation accuracy of 0.59, compared to MLP’s test accuracy of 0.3917 and validation accuracy of 0.54. Despite this, both models’ raw data performance was below random guessing, highlighting the importance of data preprocessing when implementing traditional ML models for intelligent CM.</p> <div class="row justify-content-sm-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/Confusion_matrix_mlp-480.webp 480w,/assets/img/Confusion_matrix_mlp-800.webp 800w,/assets/img/Confusion_matrix_mlp-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/Confusion_matrix_mlp.jpg" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figcaption style="text-align: center; margin-top: 10px;">A confusion matrix results of the MLP model trained with processed data.</figcaption> </div> </div> <div class="row justify-content-sm-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/confusion_matrix_svm-480.webp 480w,/assets/img/confusion_matrix_svm-800.webp 800w,/assets/img/confusion_matrix_svm-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/confusion_matrix_svm.jpg" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figcaption style="text-align: center; margin-top: 10px;">A confusion matrix results of the SVM model trained with processed data.</figcaption> </div> </div> <h2 id="conclusion">Conclusion</h2> <p>This project successfully demonstrated the potential of ML models in mechanical engineering diagnostics. It functions as a good starting point for any mechanical engineering student who is interested in intelligent fault diagnosis, or wants to learn basic ML techniques applicable to mechanical engineering problems.</p> <h2 id="things-to-improve">Things to improve</h2> <p>Here are some things that anyone wanting to replicate this project can take into account and improve:</p> <ul> <li>A proper, structured hyperparameter search</li> <li>Further comparisons between different ML models/techniques</li> <li>Further comparisons of loss functions/activation functions/ model structures</li> <li>Better visualization of the results</li> <li>Further ablation of the results</li> </ul> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Aku T. Karhinen. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?5d75c11f89cd96294bf5e6dd1ee1bb30"></script> <script defer src="/assets/js/common.js?fcfacfb8c6281f5e68d5a7d348186eb1"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>